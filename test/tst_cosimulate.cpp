#include <QDir>
#include <QProcess>
#include <QResource>
#include <QStringList>
#include <QtTest/QTest>

#include <optional>

#include "processorhandler.h"
#include "processorregistry.h"

#include "edittab.h"

/**
 * Ripes co-simulation
 * For a given test program, executes a reference model (RVSS) to generate a trace of register modifications.
 * Then, the target processor is simulated, and its register trace is compared to the reference trace.
 * From this, we can detect whether (and where) register state divergence occurs, which indicates an error in a
 * processor implementation
 */

using namespace Ripes;
using namespace vsrtl::core;
using RVISA = ISAInfo<ISA::RV32I>;

// Maximum cycle count
static constexpr unsigned s_maxCycles = 1000000;
using Registers = std::map<int, uint32_t>;
using Trace = std::map<int, Registers>;
static constexpr unsigned s_ecallreg = 10;  // a0

// Reference model
// All tests will be compared against the trace generated by this processor model.
static constexpr ProcessorID s_referenceModel = ProcessorID::RVSS;

// Test selection
// s_testFiles denotes all of the test files that will be included in the cosimulation run for each processor.
const QString s_testdir = VSRTL_RISCV_TEST_DIR;
const std::vector<LoadFileParams> s_testFiles = {
    LoadFileParams{QString(s_testdir + QDir::separator() + "../../examples/ELF/RanPi"), SourceType::ExternalELF, 0, 0}};

class tst_Cosimulate : public QObject {
    Q_OBJECT

private:
    void cosimulate(const ProcessorID& id, const QStringList& extensions);
    Trace generateReferenceTrace(const QStringList& extensions);
    void handleSysCall();
    void executeSimulator(Trace& outTrace, const Trace* refTrace = nullptr);
    Registers dumpRegs();
    QString generateErrorReport(const Registers& lhs, const Registers& rhs, unsigned cycles) const;

    bool m_stop = false;
    QString m_err;
    LoadFileParams m_currentTest;
    EditTab* m_loader;

private slots:
    /**
     * PROCESSOR MODELS TO TEST
     * Each of the following functions shall indicate a processor model to co-simulate.
     */
    void testRV5S() { cosimulate(ProcessorID::RV5S, {"M"}); }
};

void tst_Cosimulate::handleSysCall() {
    unsigned status = ProcessorHandler::get()->getProcessor()->getRegister(RegisterFileType::GPR, s_ecallreg);
    if (status == 10) {
        m_stop = true;
    }
}

Registers tst_Cosimulate::dumpRegs() {
    Registers regs;
    for (unsigned i = 0; i < ProcessorHandler::get()->currentISA()->regCnt(); i++) {
        regs[i] = ProcessorHandler::get()->getProcessor()->getRegister(RegisterFileType::GPR, i);
    }
    return regs;
}

std::optional<int> regNeq(const Registers& lhs, const Registers& rhs) {
    bool eq = true;
    for (const auto& it : lhs) {
        eq &= it.second == rhs.at(it.first);
        if (!eq) {
            return it.first;
        }
    }
    return std::nullopt;
}

QString tst_Cosimulate::generateErrorReport(const Registers& lhs, const Registers& rhs, unsigned cycles) const {
    QString err;
    err +=
        "\nDiscrepancy at cycle " + QString::number(cycles) + " while executing test: " + m_currentTest.filepath + "\n";
    err +=
        "Processor PC is: 0x" + QString::number(ProcessorHandler::get()->getProcessor()->getPcForStage(0), 16) + "\n";

    int idx = regNeq(lhs, rhs).value();
    err += "Difference in register #: " + QString::number(idx) + "\n";
    err +=
        "\t expected: 0x" + QString::number(rhs.at(idx), 16) + "\tactual: 0x" + QString::number(lhs.at(idx), 16) + "\n";

    return err;
}

/**
 * @brief tst_Cosimulate::executeSimulator
 * Runs the currently loaded simulator on the currently loaded program, generating a register trace while doing so.
 * If @p refTrace is provided, the generated trace is compared to the reference trace and the test fails if a
 * discrepancy is detected.
 */
void tst_Cosimulate::executeSimulator(Trace& trace, const Trace* refTrace) {
    m_loader->loadFile(m_currentTest);

    m_stop = false;
    m_err = QString();
    bool maxCyclesReached = false;
    unsigned cycles = 0;
    trace[cycles] = dumpRegs();

    const Registers* cmpRegStatePtr = nullptr;
    typeof(refTrace->begin()) cmpRegState;
    if (refTrace) {
        cmpRegState = refTrace->begin();
        cmpRegState++;  // skip initial state
        cmpRegStatePtr = &cmpRegState->second;
    }

    do {
        ProcessorHandler::get()->getProcessorNonConst()->clock();
        cycles++;

        Registers regs = dumpRegs();
        // Detect change in current register state
        if (regNeq(regs, trace.rbegin()->second)) {
            trace[cycles] = regs;

            // Check whether change corresponds to expected change in comparison trace
            if (cmpRegStatePtr) {
                if (regNeq(regs, *cmpRegStatePtr)) {
                    const QString err = generateErrorReport(regs, *cmpRegStatePtr, cycles);
                    QFAIL(err.toStdString().c_str());
                }

                cmpRegState++;
                cmpRegStatePtr = &cmpRegState->second;
            }
        }

        maxCyclesReached = cycles >= s_maxCycles;
        m_stop |= maxCyclesReached || ProcessorHandler::get()->getProcessor()->finished();
    } while (!m_stop);

    if (maxCyclesReached) {
        QFAIL("Maximum cycles reached");
    }
}

/**
 * @brief tst_Cosimulate::generateTrace
 * Executes program @p spProgram on the single-cycle processor model, to generate a reference trace.
 */
Trace tst_Cosimulate::generateReferenceTrace(const QStringList& extensions) {
    ProcessorHandler::get()->selectProcessor(s_referenceModel, extensions);
    Trace trace;
    executeSimulator(trace);
    return trace;
}

/**
 * @brief tst_Cosimulate::cosimulate
 * Cosimulate a given processor with a reference model.
 * The cosimulation is quite inefficient, since we don't concurrently execute two processors but rather generate a
 * reference trace from a reference model, and then execute a test model, generate a trace for this, and comprare this
 * trace with the reference trace. The reason for this is, that only a single processor model can be instantiated at
 * once in Ripes, due to the static nature of the ProcessorHandler.
 */
void tst_Cosimulate::cosimulate(const ProcessorID& id, const QStringList& extensions) {
    m_loader = new EditTab(new QToolBar(), nullptr);
    connect(m_loader, &EditTab::programChanged, ProcessorHandler::get(), &ProcessorHandler::loadProgram);

    for (const auto& test : s_testFiles) {
        m_currentTest = test;

        connect(ProcessorHandler::get(), &ProcessorHandler::reqProcessorReset,
                [=] { ProcessorHandler::get()->getProcessorNonConst()->reset(); });
        // Override the ProcessorHandler's ECALL handling. In doing so, we verify whether the correct test value was
        // reached.
        ProcessorHandler::get()->getProcessorNonConst()->handleSysCall.Connect(this, &tst_Cosimulate::handleSysCall);

        std::cout << "Generating reference trace..." << std::endl;
        auto referenceTrace = generateReferenceTrace(extensions);
        ProcessorHandler::get()->selectProcessor(id, extensions);

        Trace trace;
        std::cout << "Cosimulating..." << std::endl;
        executeSimulator(trace, &referenceTrace);
    }
}

QTEST_MAIN(tst_Cosimulate)
#include "tst_cosimulate.moc"
